<?php

/**
 * @file
 * Ecobee notifications
 */

/**
 * Implementation of hook_perm
 */


/**
 * Implementation of hook_notifications.
 *
 * Implements a new subscription type for a given Topic in a given group.
 */
function notifications_vocabulary_1_notifications($op, &$arg0 = NULL, $arg1 = NULL, $arg2 = NULL) {

dsm( 'notifications_vocabulary_1_notifications - ' . $op );

  switch ($op) {
    case 'subscription types' :
      //dsm( 'subscription types' );
    
      $types['vocabulary'] = array(
        'event_type' => 'node',  // This will be for node events (insert, update, comment...)
        'title' => t('Vocabulary'),
        'access' => 'subscribe to vocabulary', // New permission must be created somewhere else
        'user page' => 'user/%user/notifications/vocabulary', // Menu item for a page that must be defined somewhere else
        'fields' => array('vocabulary'), // These are the condition fields this subscription needs, in this case just the vid
        'description' => t('Subscribe to all content tagged with a term of a vocabulary.'),
      );
      return $types;

    break;
    
    case 'subscription fields' :
      //dsm( 'subscription fields' );
    
      $fields['vocabulary'] = array(
        'name' => t('Vocabulary'),
        'field' => 'vocabulary', // This seems to relate to case 'query'. See below in this fn.
        'type' => 'int',
        // This one should return an array of vid => name. Wil be used when displaying the subscription for naming the value
        // and for a drop down field when creating a subscription with this field
        'options callback' => '_vocabulary_notifications_options',
      );
      return $fields;
    
    break;

   case 'object types':
      //notifications_include('object.inc');
      //$types['vocabulary'] = array(
        //'name' => t('Vocabulary'),
        //'key_field' => 'vocabulary',
        //'load callback' => 'taxonomy_vocabulary_load',
////        'autocomplete path' => 'notifications/autocomplete/node/title',
////        'autocomplete callback' => 'notifications_node_nid2autocomplete',
        //'format callback' => 'notifications_vocabulary_1_vid2name',
        //'value callback' => 'notifications_vocabulary_1_name2vid',
////        'access callback' => 'notifications_node_user_access',
////        'file' => 'node.inc',
      //);     
      //return $types;
    break;
    
    case 'query' :
      //dsm( 'query' );
  
      if ( $arg0 === 'event' && $arg1 === 'node' ) { 
        // (3)
        $event = $arg2;
        $node = $event->objects['node']; // This object will have been loaded by notifications_content
        $vids = mycustomfunction_get_vids_for_a_node($node); // We will get an array of vids for the node
        $query[]['fields']['vocabulary'] = $vids;
        return $query; // With these values, the query builder will build the query to match this conditions
      } else if ( $arg0 === 'node' ) {
        // If we want to display these options for nodes as node links, we can add some more. These are extensions handled by notifications_content module, not by notifications itself.
        // To query enabled subscriptions of this type for a node, we need to implement hook_notifications('query', 'node', $node). Will be the same as the one in (3)
        //$event = $arg1;
        //$node = $event->objects['node']; // This object will have been loaded by notifications_content
        //$vids = mycustomfunction_get_vids_for_a_node($node); // We will get an array of vids for the node
        //$query[]['fields']['vocabulary'] = $vids;
        //return $query; // With these values, the query builder will build the query to match this conditions
      }
      
    break;
    
    case 'node options' :
    
      //$account = $arg0;
      //$node = $arg1;
      //// First we check these subscriptions are enabled for this content type (notifications_content module)
      //if (notifications_content_type_enabled($node->type, 'vocabulary')) {
         //// For each vocabulary linked to the node, we need to return one of this:
         //foreach ($vocabularies as $vocabulary) {
           //$options[] = array(
             //'name' => t('Vocabulary @name'),
             //'type' => 'vocabulary',
             //'fields' => array('vocabulary' => $vocabulary->vid),
          //);
        //}
        //return $options;
      //}
      // This will produce, with the help of notifications_ui module, one link for each vocabulary the node is in like "Subscribe to Vocabulary 1", "Unsubscribe to vocabulary 2", etc...
      
    break;
  }
}

/**
 * Implementation of hook_notifications_object_node()
 */
function notifications_vocabulary_1_notifications_object_node($op, $node, $account = NULL) {
  dsm( 'notifications_vocabulary_1_content_notifications_object_node - ' . $op );

  switch ($op) {
    case 'conditions':

      $conditions = array();

      // At the time that this hook op is called, $node->taxonomy is just an
      // array of taxonomy term IDs.
      foreach ( $node->taxonomy as $tid ) {
        $term = taxonomy_get_term( $tid );
        $conditions['vocabulary'][] = $term->vid;
      }

      return $conditions;

    break;

    case 'subscriptions':
    
      // Return available subscription options for this node and this user account
      $options = array();
      if (notifications_subscription_type_enabled('vocabulary')) {
        
        $vids = array();

        // At the time that this hook op is called, $node->taxonomy is an array
        // of taxonomy term objects.
        foreach( $node->taxonomy as $term ) {
          $vids[$term->vid] = $term->vid;
        }
        
        foreach ( $node->taxonomy as $term ) {
          $vocab = taxonomy_vocabulary_load( $term->vid );
          $options[] = array(
            'name' => t('Posts tagged from vocabulary "@vocab"', array('@vocab' => $vocab->name )),
            'type' => 'vocabulary',
            'fields' => array('vocabulary' => $vid),
          );
        }
      }
      return $options;
      
    break;
  }
}


  /**
   * Implementation of hook_notifications.
   *
   * Implements a new subscription type for a given Topic in a given group.
   */
  function hoky_notifications($op, &$arg0 = NULL, $arg1 = NULL, $arg2 = NULL) {

    switch ($op) {
      case 'subscription types' :
      
        $types['network_topic'] = array(
        
          // This will be for node events (insert, update, comment...)
          'event_type' => 'node',
          
          'title' => t('Network topic'),
          
          // New permission must be defined in a hook_perm
          'access' => 'subscribe to network topic',
          
          // A page for a user to manage their Network topic subscriptions.
          // The same path must also be defined by a menu item in a hook_menu.
          'user page' => 'user/%user/notifications/network_topic',
          
          // These are the condition fields this subscription needs, in this case just the vid
          'fields' => array( /*'network',*/ 'topic'),
          
          'description' => t('Subscribe to content, in a given network, tagged with a specific term.'),
        );
        return $types;

      break;
      
      case 'subscription fields' :
      
        $fields['network'] = array(
        
          'name' => t('Network'),
          
          // Okay this seems a bit recursive; a field within a field.
          // I'm going to assume for now that this is the "machine name" of the field.
          'field' => 'network',
          
          // A very raw exposure to type?!
          'type' => 'int',
          
          // This one should return an array of vid => name. Wil be used when displaying the subscription for naming the value
          // and for a drop down field when creating a subscription with this field
          'options callback' => '_vocabulary_notifications_options',
        );
        return $fields;
      
      break;
    }
  }


















