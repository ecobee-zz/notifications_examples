<?php

/**
 * @file
 * Defines vocabulary subscription using a notifications 'object type'.
 * 
 * This module builds on notifications_vocabulary_1 by using the 'object types'
 * operation in hook_notifications. Functionally, this module should be
 * identical although some elements of UI will look different.
 * 
 * Again, no access restrictions are being imposed anywhere.
 */

/**
 * Implementation of hook_menu.
 */
function notifications_vocabulary_2_menu() {

  // Defines a path to a an autocomplete callback. This will be called when a
  // user creates a subscription using their user-specific subscription page at
  //   /user/%/notifications/add/vocabulary2
  $items['notifications/autocomplete/vocabulary2/name'] = array(
    'title' => 'Vocabulary2 autocomplete',
    'page callback' => '_notifications_vocabulary_2_autocomplete',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_notifications.
 *
 * Defines a vocabulary subscription type and its single field, also called
 * vocabulary.
 */
function notifications_vocabulary_2_notifications($op, &$arg0 = NULL, $arg1 = NULL, $arg2 = NULL) {

  switch ($op) {

    // This op gives the programmer the chance to define one or more
    // subscription types. A subscription type defines the conditions under
    // which a user will recieve a notification. It relies an event type and
    // one or more fields (see below).
    case 'subscription types' :
      //dsm( 'hook_notifications : subscription types' );
    
      $types['vocabulary2'] = array(

        // This subscription type will create a notifications of 'node' events.
        // Point of interest: Three 'node' events (insert, update, comment) are
        // defined in the notifications_content module, in the 'event types' op
        // of the hook_notifications implementation.
        'event_type' => 'node',
        
        // This subscription type will be presented to the user as 'vocabulary2'
        // (at least in English).
        'title' => t('Vocabulary2'),
        
        // This module defines a single subscription field ('vocabulary2') and
        // that that field is used by this subscription type.
        // See the 'subscription fields' op below for a description of what a
        // subscription field is.
        'fields' => array('vocabulary2'),
        
        // Where appropriate, a user will see this description of the
        // 'vocabulary2' description type (at least in English).
        'description' => t('Subscribe to all content tagged with a term of a vocabulary.'),
      );

      return $types;

    break;
    
    // This op gives the programmer the chance to define one or more
    // subscription fields. A subscription field defines a property that marks
    // a piece of content as suitable for triggering notifications for a given
    // subscription.
    case 'subscription fields' :
      //dsm( 'hook_notifications : subscription fields' );
    
      $fields['vocabulary2'] = array(
      
        // This subscription field will be presented to the user as 'vocabulary2'
        // (at least in English).
        'name' => t('Vocabulary2'),
        
        // @todo  - play with the name supplied here and the name of the
        // subscription field key to see what effect they have on behaviour: At
        // the moment, it looks like our field has a field. Is this the case or
        // is this used for the name of the field rather than the 'vocabulary2'
        // key above?
        'field' => 'vocabulary2',
        
        // The type of value that this field should contain. A PHP type.
        'type' => 'int',
        
        // NOTE: Most text keys required by the notifications system use
        // spaces, but this key uses an underscore. Potentially lots of fun if
        // you forget.
        'object_type' => 'vocabulary2',
      );
      return $fields;
    
    break;
    
    case 'object types':

      notifications_include('object.inc');
 
      $types['vocabulary2'] = array(
        'name' => t('Vocabulary2'),
        'key_field' => 'vid',
        'load callback' => 'taxonomy_vocabulary_load',
        'autocomplete path' => 'notifications/autocomplete/vocabulary2/name',
        'autocomplete callback' => '_notifications_vocabulary_2_vid2autocomplete',
        'format callback' => '_notifications_vocabulary_2_vid2name',
        'value callback' => '_notifications_vocabulary_2_name2vid',
      );     
      return $types;

    break;
  }
}

/**
 * Menu callback - Retrieve a JSON object containing autocomplete suggestions.
 * 
 * This autocomplete function is made accessible by being the page callback for
 * a menu item defined in hook_menu (above). The path to that menu item is
 * used as the value for the 'autocomplete callback' key in the
 * hook_notifications 'object types' operation (above).
 */
function _notifications_vocabulary_2_autocomplete($string = '') {
  $matches = array();
  
  if ($string) {
    $result = db_query_range("SELECT vid, name FROM {vocabulary} WHERE LOWER(name) LIKE LOWER('%s%%')", $string, 0, 10);

    while ($vocab = db_fetch_object($result)) {
      $matches[$vocab->name . ' [vid:' . $vocab->vid . ']'] = '<div class="reference-autocomplete">'. check_plain($vocab->name) . '</div>';
    }
  }

  drupal_json($matches);
}

/**
 * Get a string representation of a vocabulary from its ID.
 * 
 * This function is called from the user specific admin page at
 *   /user/%/notifications/subscriptions
 * in order to show vocabularies as names rather than numbers.
 * 
 * @param $vid
 *   The vocabulary ID.
 * @param $html
 *   A boolean dictating whether to return html (rather than plain text).
 * 
 * @return
 *   String representation of a vocabulary
 */
function _notifications_vocabulary_2_vid2name($vid, $html = FALSE) {
  if ( $vocab = taxonomy_vocabulary_load( $vid ) ) {
    return check_plain($vocab->name);
  } else {
    return t('Vocabulary not found');
  }
}

/**
 * Convert from vocabulary name or autocomplete value (name [vid:x]) to vid.
 * 
 * This callback is called when a user creates a subscription using their
 * user-specific subscription at
 *   /user/%/notifications/add/vocabulary2
 * When the page is submitted, this fn determines the correct vocabulary ID in
 * order to parameterise the new subscription correctly.
 */
function _notifications_vocabulary_2_name2vid($string, $field = NULL, $types = array()) {
  dsm( $string );
  if (!empty($string)) {
    preg_match('/^(?:\s*|(.*) )?\[\s*vid\s*:\s*(\d+)\s*\]$/', $string, $matches);
    if (!empty($matches)) {
      // Explicit [vid:n].
      list(, $name, $vid) = $matches;
      if (!empty($name) && ($vocab = taxonomy_vocabulary_load($vid)) && $name != $vocab->name) {
        if ($field) {
          form_set_error($field, t('Vocabulary name mismatch. Please check your selection.'));
        }
        $vid = NULL;
      }
    }
    else {
      // No explicit vid.
      $vid = db_result( db_query("SELECT vid FROM {vocabulary} WHERE LOWER(name) = LOWER('%s')", $string ) );
      if ( !$vid  &&  $field ) {
        form_set_error($field, t('Found no vocabulary of that name: %name', array('%name' => $string)));
      }
    }
  }
  dsm( $vid );
  return !empty($vid) ? $vid : NULL;  
}

/**
 * Not yet seen this fn called.
 */
function _notifications_vocabulary_2_vid2autocomplete($vid, $subscription = NULL) {
  dsm( '_notifications_vocabulary_2_vid2autocomplete' );
}



/**
 * Implementation of hook_notifications_object_node()
 */
function notifications_vocabulary_2_notifications_object_node($op, $node, $account = NULL) {

  switch ($op) {
    
    // This op is called whenever an event, of an event type known to the
    // notifications system, occurs. Our module gets the chance to extract data
    // from the relevant content, which the notifications system can compare to
    // subscriptions in order to determine whether to trigger a notification.
    case 'conditions':
      //dsm( 'hook_notifications_object_node : conditions' );

      $conditions = array();

      $vids = _notifications_vocabulary_2_get_vocabulary_ids_from_node( $node );

      foreach ( $vids as $vid ) {
        // The only subscription field we are concerned with is 'vocabulary2' so
        // we are extracting all vocabularies from which this node has been
        // tagged.
        $conditions['vocabulary2'][] = $vid;
      }

      return $conditions;

    break;

    // This op is called in order to present the user with a set of subscription
    // (and unsubscription) links relevant to the content that they are viewing.
    // NOTE: The 'vocabulary2' subscription type will still function if this op
    // is commented out. 
    case 'subscriptions':
      //dsm( 'hook_notifications_object_node : subscriptions' );
    
      $options = array();
      if ( notifications_subscription_type_enabled('vocabulary2') ) {
        
        $vids = _notifications_vocabulary_2_get_vocabulary_ids_from_node( $node );
        
        // For each vocabulary from which the current content is tagged, give
        // the notifications system enough information to present the user with
        // (un)subscribe links.
        foreach ( $vids as $vid ) {
          $vocab = taxonomy_vocabulary_load( $vid );
          $options[] = array(
            
            // The text of the link to be shown to the user
            'name' => t('Posts tagged from vocabulary "@vocab"', array('@vocab' => $vocab->name )),
            
            // The relevant subscription type. (The notifications system will
            // create a subscription of this type in response to a click on the
            // link.)
            'type' => 'vocabulary2',
            
            // The relevant subscription fields (only one in our case) and the
            // value for each field to be used to create the subscription.
            'fields' => array('vocabulary2' => $vid),
          );
        }
      }
      return $options;
      
    break;
  }
}

/**
 * Gets the vocabularies IDs of any taxonomy terms associated with a node.
 * 
 * @param $node
 *   A node object
 *
 * @return
 *   An array, either empty or containing vocabulary IDs ( vid => vid ).
 */
function _notifications_vocabulary_2_get_vocabulary_ids_from_node( $node ) {
 
  // Does the node have no taxonomy terms associated with it?
  if ( ! isset( $node->taxonomy )
       ||  ! is_array( $node->taxonomy )
       ||  empty( $node->taxonomy ) ) {
    return array();
  }
  
  $result = array();
  
  foreach ( $node->taxonomy as $term ) {

    if ( ! is_object( $term ) ) {
      // As the term is not an object, assume it is a term ID and use it to
      // load the relevant term object.
      $term = taxonomy_get_term( $term );
    }

    $result[$term->vid] = $term->vid;
  }
  
  return $result;
}














